/*******************************************************
 * Amir – Drahtrichter UI (Portrait 240x320)
 * ESP32 + ILI9341 (TFT_eSPI) + Touch (XPT2046/optional FT6206)
 * Voll flexible Konfiguration für Joystick (X/Y/Z) & Relais
 * Autor: Amir Mobasheraghdam
 *******************************************************/

#include <TFT_eSPI.h>
#include <Wire.h>
// #define USE_CAP_TOUCH   // aktivieren, wenn FT6206 (kapazitiv) genutzt wird
#ifdef USE_CAP_TOUCH
  #include <Adafruit_FT6206.h>
  Adafruit_FT6206 ctp;
#endif

/***************** Hardware-Standardpins *****************/
// Joystick-Pins (ADC)
#define PIN_JOY_X   35
#define PIN_JOY_Y   34
#define PIN_JOY_Z  -1    // optionaler dritter Analog-Pin; -1 = nicht vorhanden
#define PIN_JOY_SW  27   // Taster (LOW-aktiv)

// Sonstige IO
#define PIN_SENSOR  33
#define PIN_RELAY   25

// I2C (PX2 + ggf. FT6206): SDA=21, SCL=22 (ESP32-Standard)

/***************** Drucksensor Honeywell PX2 *****************/
#define PX2_ADDR   0x28
#define P_MIN      0.0f
#define P_MAX      1034.21f
#define TARGET_MIN 400.0f
#define TARGET_MAX 500.0f

/***************** Display / Farben *****************/
#define PORTRAIT_ROTATION 0
#define ORANGE_DARK    0x02BF
#define ORANGE_MAIN    0x02BF
#define ORANGE_LIGHT   0x02FF
#define ORANGE_ACCENT  0x04FF
#define ORANGE_BG      0x003F
#define COLOR_TEXT     TFT_WHITE
#define COLOR_OK       0x07E0
#define COLOR_BAD      0x00F8
#define COLOR_FRAME    TFT_BLACK

/***************** --- FLEXIBLE KONFIGURATION --- *****************/
// Achsen-IDs
enum AxisID { AXIS_X=0, AXIS_Y=1, AXIS_Z=2, AXIS_NONE=3 };
// Richtungen
enum Dir2D  { DIR_UP, DIR_DOWN, DIR_LEFT, DIR_RIGHT };

// Analoge Grenzen
const int ADC_MIN=0, ADC_MAX=4095, ADC_CENTER=2048;

// Konfiguration der Achsen (Pin & invert)
struct AxisCfg {
  int  pin;       // ADC-Pin oder -1
  bool invert;    // true = invertieren
  bool enabled;   // ob diese Achse genutzt wird
};

struct JoystickCfg {
  AxisID navAxis;       // Achse für Menü-Navigation (AXIS_X/AXIS_Y/AXIS_Z)
  AxisID triggerAxis;   // Achse für Trigger (Relais) in Modus "Joystick"
  Dir2D  triggerDir;    // Richtung, die Trigger auslöst
  int    deadzone;      // Totzone um CENTER
  int    navThreshold;  // Empfindlichkeit Navigation
  uint16_t navRepeatMs; // Repeatrate Navigation (ms)
};

struct RelayCfg {
  bool activeLow;           // Relais-Logik: true = ACTIVE LOW (üblich bei Modulen)
  uint16_t t_sensor_ms;     // Sensor-Impulsdauer
  uint16_t t_joy_ms;        // Joystick-Impulsdauer
  uint16_t t_auto_on_ms;    // Auto-EIN-Zeit
  uint16_t t_auto_off_ms;   // Auto-AUS-Zeit
};

// >>> HIER NUR ANPASSEN – Rest des Codes nutzt diese Werte <<<
AxisCfg axisCfg[3] = {
  { PIN_JOY_X, false, PIN_JOY_X>=0 },   // X
  { PIN_JOY_Y, true , PIN_JOY_Y>=0 },   // Y (invertiert)
  { PIN_JOY_Z, false, PIN_JOY_Z>=0 }    // Z (optional)
};

JoystickCfg joyCfg = {
  /*navAxis     */ AXIS_Y,        // Navigation standard auf Y
  /*triggerAxis */ AXIS_Y,        // Trigger-Achse (kann X/Y/Z sein)
  /*triggerDir  */ DIR_DOWN,      // Richtung für Trigger (UP/DOWN/LEFT/RIGHT)
  /*deadzone    */ 160,
  /*navThreshold*/ 450,
  /*navRepeatMs */ 180
};

RelayCfg relayCfg = {
  /*activeLow   */ true,          // viele Module sind LOW-aktiv
  /*t_sensor_ms */ 10000,
  /*t_joy_ms    */ 4000,
  /*t_auto_on   */ 5000,
  /*t_auto_off  */ 2000
};
/***************** --- ENDE KONFIGURATION --- *****************/

/***************** Globale Zustände *****************/
TFT_eSPI tft;
#ifndef USE_CAP_TOUCH
uint16_t calData[5] = { 370, 3530, 370, 3490, 7 }; // nach Kalibrierung ersetzen!
#endif

const char* menuItems[] = { "Sensor-Modus", "Joystick-Modus", "Auto-Modus", "Druck-Anzeige" };
const uint8_t menuCount = sizeof(menuItems)/sizeof(menuItems[0]);
uint8_t currentSelection = 0;
int8_t  activeMode = -1;

bool relayActive=false;
unsigned long relayTimer=0;
float currentPressure=0.0f;

unsigned long lastButtonPress=0;
unsigned long lastNavTime=0;
uint8_t buttonClickCount=0;
unsigned long lastClickTime=0;

/***************** Vorwärtsdeklarationen *****************/
void drawMainMenu(); void drawHeader(); void drawFooter(const char* text);
void drawMenuList(); void drawMenuItem(int y,const char* label,bool sel);
void drawPressureBadgeInHeader(float kPa);

void handleMain(); void handleButtonPress(); bool canExitCurrentMode();
void showModeStartScreen(const char* modeName);
void drawSensorModeUI();     void runSensorMode();
void drawJoystickModeUI();   void runJoystickMode();
void drawAutoModeUI();       void runAutoMode();
void drawPressureDisplayUI();void runPressureDisplay();

float readPressureSensor();
void drawProgressBar(int cx,int y,int w,int h,float pct,uint16_t col,uint16_t bg);
void activateRelay(uint16_t ms);
void checkRelayTimer();

bool readAxis(AxisID id,int &val);        // liest Achse (inkl. invert)
bool axisGoes(AxisID id, Dir2D dir);      // prüft Richtung (mit Threshold)
void handleTouchMainMenu();
bool getTouch(uint16_t &x,uint16_t &y);

/***************** Setup *****************/
void setup(){
  Serial.begin(115200);
  Wire.begin();

  pinMode(PIN_JOY_SW, INPUT_PULLUP);
  pinMode(PIN_SENSOR, INPUT);
  pinMode(PIN_RELAY, OUTPUT);
  digitalWrite(PIN_RELAY, relayCfg.activeLow ? HIGH : LOW); // AUS

  tft.init();
  tft.setRotation(PORTRAIT_ROTATION);
  tft.fillScreen(ORANGE_BG);

#ifndef USE_CAP_TOUCH
  tft.setTouch(calData);
#else
  if (!ctp.begin(40)) Serial.println("FT6206 nicht gefunden.");
#endif

  drawMainMenu();
}

/***************** Loop *****************/
void loop(){
  // Tastentriple/Single
  bool buttonPressed = (digitalRead(PIN_JOY_SW)==LOW);
  if (buttonPressed && millis()-lastButtonPress>300){
    handleButtonPress();
    lastButtonPress = millis();
  }

  // Drucksensor
  currentPressure = readPressureSensor();

  // Touch im Menü
  if (activeMode==-1) handleTouchMainMenu();

  // Modi
  switch(activeMode){
    case 0: runSensorMode(); break;
    case 1: runJoystickMode(); break;
    case 2: runAutoMode(); break;
    case 3: runPressureDisplay(); break;
    default: handleMain(); // Navigation per konfigurierter Achse
  }
}

/***************** Navigation im Hauptmenü *****************/
void handleMain(){
  int v;
  if (readAxis(joyCfg.navAxis, v)){
    int dy = v - ADC_CENTER;
    if (abs(dy)>joyCfg.deadzone && millis()-lastNavTime>joyCfg.navRepeatMs){
      if (dy> joyCfg.navThreshold){
        currentSelection = (currentSelection==0)? (menuCount-1):(currentSelection-1);
        drawMenuList(); lastNavTime=millis();
      } else if (dy< -joyCfg.navThreshold){
        currentSelection = (currentSelection+1)%menuCount;
        drawMenuList(); lastNavTime=millis();
      }
    }
  }
  drawHeader();
}

/***************** Buttons *****************/
void handleButtonPress(){
  if (millis()-lastClickTime<500) buttonClickCount++;
  else buttonClickCount=1;
  lastClickTime=millis();

  if (activeMode==-1){
    if (buttonClickCount==1){
      activeMode=currentSelection;
      showModeStartScreen(menuItems[currentSelection]);
    }
  } else {
    if (buttonClickCount>=3 && canExitCurrentMode()){
      activeMode=-1; buttonClickCount=0; drawMainMenu();
    }
  }
}

bool canExitCurrentMode(){ return (activeMode!=2) || !relayActive; }

/***************** UI – Hauptmenü *****************/
void drawMainMenu(){
  tft.fillScreen(ORANGE_BG);
  drawHeader();
  drawMenuList();
  drawFooter("1x Klick: Start  |  3x Klick: Zurück");
}

void drawHeader(){
  int W=tft.width(), H=tft.height();
  tft.fillRect(0,0,W,HDR_H,ORANGE_MAIN);
  tft.setTextColor(COLOR_TEXT,ORANGE_MAIN);
  tft.setTextDatum(TL_DATUM);
  tft.setTextSize(2);
  tft.drawString("Igus – Drahtrichter", SIDE_PAD, 8);
  tft.setTextDatum(TR_DATUM);
  tft.drawString(relayActive?"Aktiv":"Leerlauf", W-SIDE_PAD, 8);
  drawPressureBadgeInHeader(currentPressure);
}

void drawMenuList(){
  int W=tft.width(), H=tft.height();
  tft.fillRect(0,HDR_H,W,H-HDR_H-FTR_H,ORANGE_BG);
  int itemH=44, gap=10;
  int totalH=(itemH*menuCount)+(gap*(menuCount-1));
  int startY = HDR_H + ((H-HDR_H-FTR_H)-totalH)/2;
  for (uint8_t i=0;i<menuCount;i++){
    drawMenuItem(startY + i*(itemH+gap), menuItems[i], i==currentSelection);
  }
}

void drawMenuItem(int y,const char* label,bool sel){
  int W=tft.width();
  int x=SIDE_PAD, w=W-2*SIDE_PAD, h=44, r=10;
  if (sel){
    tft.fillRoundRect(x,y,w,h,r,ORANGE_ACCENT);
    tft.drawRoundRect(x,y,w,h,r,ORANGE_DARK);
    tft.setTextColor(TFT_BLACK,ORANGE_ACCENT);
  } else {
    tft.fillRoundRect(x,y,w,h,r,ORANGE_BG);
    tft.drawRoundRect(x,y,w,h,r,ORANGE_DARK);
    tft.setTextColor(COLOR_TEXT,ORANGE_BG);
  }
  tft.setTextSize(2); tft.setTextDatum(ML_DATUM);
  tft.drawString(label, x+10, y+h/2);
}

void drawFooter(const char* text){
  int W=tft.width(), H=tft.height();
  tft.fillRect(0,H-FTR_H,W,FTR_H,ORANGE_DARK);
  tft.setTextColor(COLOR_TEXT,ORANGE_DARK);
  tft.setTextSize(1); tft.setTextDatum(MC_DATUM);
  tft.drawString(text, W/2, H-FTR_H/2);
}

void drawPressureBadgeInHeader(float kPa){
  int W=tft.width();
  int x=W-128-SIDE_PAD, y=22, w=128, h=18, r=9;
  tft.fillRect(x,y,w,h,ORANGE_MAIN);
  if (kPa<0){
    tft.setTextDatum(TR_DATUM);
    tft.setTextColor(COLOR_TEXT,ORANGE_MAIN);
    tft.drawString("Kein Sensor", W-SIDE_PAD, 24);
    return;
  }
  bool ok=(kPa>=TARGET_MIN && kPa<=TARGET_MAX);
  uint16_t bg= ok?COLOR_OK:COLOR_BAD;
  tft.fillRoundRect(x,y,w,h,r,bg);
  tft.drawRoundRect(x,y,w,h,r,TFT_BLACK);
  tft.setTextDatum(MC_DATUM); tft.setTextSize(1); tft.setTextColor(TFT_BLACK,bg);
  char buf[28]; snprintf(buf,sizeof(buf),"%s | %.0f kPa", ok?"Druck OK":"Druck !", kPa);
  tft.drawString(buf, x+w/2, y+h/2);
}

/***************** Mode-Start *****************/
void showModeStartScreen(const char* modeName){
  int W=tft.width();
  tft.fillScreen(ORANGE_DARK);
  tft.fillRoundRect(SIDE_PAD,HDR_H+10,W-2*SIDE_PAD,80,12,ORANGE_ACCENT);
  tft.setTextColor(TFT_BLACK,ORANGE_ACCENT);
  tft.setTextSize(3); tft.setTextDatum(MC_DATUM);
  tft.drawString(modeName, W/2, HDR_H+50);
  tft.setTextDatum(TL_DATUM);
  delay(350);
  switch(activeMode){
    case 0: drawSensorModeUI();break;
    case 1: drawJoystickModeUI();break;
    case 2: drawAutoModeUI();break;
    case 3: drawPressureDisplayUI();break;
  }
}

/***************** Sensor-Modus *****************/
void drawSensorModeUI(){
  tft.fillScreen(ORANGE_BG); drawHeader();
  tft.setTextColor(COLOR_TEXT,ORANGE_BG); tft.setTextSize(2);
  tft.setTextDatum(TL_DATUM);
  tft.drawString("SENSOR-MODUS", SIDE_PAD, HDR_H+8);
  tft.drawFastHLine(SIDE_PAD,HDR_H+28,tft.width()-2*SIDE_PAD,ORANGE_ACCENT);
  drawFooter("\x1A  3x Klick: Zurück");
}

void runSensorMode(){
  static bool sensorActive=false;
  if (digitalRead(PIN_SENSOR)==HIGH && !relayActive){
    activateRelay(relayCfg.t_sensor_ms);
    sensorActive=true;
    tft.fillRoundRect(SIDE_PAD,HDR_H+40,tft.width()-2*SIDE_PAD,44,10,ORANGE_ACCENT);
    tft.setTextColor(TFT_BLACK,ORANGE_ACCENT); tft.setTextSize(3);
    tft.setTextDatum(MC_DATUM); tft.drawString("AKTIVIERT!", tft.width()/2, HDR_H+62);
    tft.setTextDatum(TL_DATUM);
  }
  if (relayActive){
    float remain=(relayTimer-millis())/1000.0f;
    drawProgressBar(tft.width()/2, HDR_H+110, tft.width()-2*SIDE_PAD,12,
                    remain/(relayCfg.t_sensor_ms/1000.0f), ORANGE_ACCENT, ORANGE_DARK);
  } else if (sensorActive){
    sensorActive=false; drawSensorModeUI();
  }
  checkRelayTimer();
}

/***************** Joystick-Modus *****************/
void drawJoystickModeUI(){
  tft.fillScreen(ORANGE_BG); drawHeader();
  tft.setTextColor(COLOR_TEXT,ORANGE_BG); tft.setTextSize(2);
  tft.drawString("JOYSTICK-MODUS", SIDE_PAD, HDR_H+8);
  tft.drawFastHLine(SIDE_PAD,HDR_H+28,tft.width()-2*SIDE_PAD,ORANGE_ACCENT);

  // kleines Pad
  int cx=tft.width()/2, cy=HDR_H+120;
  tft.fillRoundRect(cx-60,cy-60,120,120,20,ORANGE_DARK);
  tft.fillCircle(cx,cy,36,ORANGE_BG);

  drawFooter("Trigger-Achse/Richtung lt. Konfig  |  3x Klick: Zurück");
}

void runJoystickMode(){
  static unsigned long lastTrigger=0;
  static bool wasActive=false;

  // Visualisierung (Stick-Punkt auf Basis X/Y, wenn vorhanden)
  int cx=tft.width()/2, cy=HDR_H+120;
  int vx=ADC_CENTER, vy=ADC_CENTER;
  readAxis(AXIS_X, vx); readAxis(AXIS_Y, vy);
  tft.fillCircle(cx,cy,36,ORANGE_BG);
  int xPos = map(vx, ADC_MIN, ADC_MAX, cx-30, cx+30);
  int yPos = map(vy, ADC_MIN, ADC_MAX, cy-30, cy+30);
  tft.fillCircle(xPos, yPos, 14, ORANGE_ACCENT);

  // Langer Druck -> zurück (nur wenn Relais AUS)
  if (digitalRead(PIN_JOY_SW)==LOW && millis()-lastButtonPress>800 && !relayActive){
    activeMode=-1; drawMainMenu(); return;
  }

  // Trigger nach Konfiguration: Achse + Richtung + Schwelle
  if (!relayActive && millis()-lastTrigger>500 && axisGoes(joyCfg.triggerAxis, joyCfg.triggerDir)){
    activateRelay(relayCfg.t_joy_ms);
    lastTrigger=millis(); wasActive=true;
    tft.fillRoundRect(SIDE_PAD,HDR_H+48,tft.width()-2*SIDE_PAD,36,10,ORANGE_ACCENT);
    tft.setTextColor(TFT_BLACK,ORANGE_ACCENT); tft.setTextSize(3);
    tft.setTextDatum(MC_DATUM); tft.drawString("AKTIV!", tft.width()/2, HDR_H+66);
    tft.setTextDatum(TL_DATUM);
  }

  if (relayActive){
    float remain=(relayTimer-millis())/1000.0f;
    drawProgressBar(tft.width()/2, HDR_H+200, tft.width()-2*SIDE_PAD,12,
                    remain/(relayCfg.t_joy_ms/1000.0f), ORANGE_ACCENT, ORANGE_DARK);
  } else if (wasActive){
    wasActive=false; drawJoystickModeUI();
  }
  checkRelayTimer();
}

/***************** Auto-Puls-Modus *****************/
void drawAutoModeUI(){
  tft.fillScreen(ORANGE_BG); drawHeader();
  tft.setTextColor(COLOR_TEXT,ORANGE_BG); tft.setTextSize(2);
  tft.drawString("AUTO-PULS-MODUS", SIDE_PAD, HDR_H+8);
  tft.drawFastHLine(SIDE_PAD,HDR_H+28,tft.width()-2*SIDE_PAD,ORANGE_ACCENT);
  drawFooter("3x Klick Zurück (nur wenn AUS)");
}

void runAutoMode(){
  static bool autoState=false;
  static unsigned long autoTimer=0;
  static bool firstRun=true;

  if (firstRun){ drawAutoModeUI(); firstRun=false; }

  uint16_t interval = autoState ? relayCfg.t_auto_on_ms : relayCfg.t_auto_off_ms;
  if (millis()-autoTimer >= interval){
    autoState=!autoState;
    digitalWrite(PIN_RELAY, (relayCfg.activeLow ? (autoState?LOW:HIGH) : (autoState?HIGH:LOW)) );
    relayActive=autoState;
    autoTimer=millis();

    tft.fillRoundRect(SIDE_PAD,HDR_H+52,tft.width()-2*SIDE_PAD,44,10, autoState?ORANGE_ACCENT:ORANGE_BG);
    tft.setTextColor(autoState?TFT_BLACK:COLOR_TEXT, autoState?ORANGE_ACCENT:ORANGE_BG);
    tft.setTextSize(3); tft.setTextDatum(MC_DATUM);
    tft.drawString(autoState?"POWER ON":"POWER OFF", tft.width()/2, HDR_H+74);
    tft.setTextDatum(TL_DATUM);
  }

  float remain=(autoTimer+interval - millis())/1000.0f;
  drawProgressBar(tft.width()/2, HDR_H+120, tft.width()-2*SIDE_PAD,12,
                  remain/(interval/1000.0f), ORANGE_ACCENT, ORANGE_DARK);

  if (!relayActive && buttonClickCount>=3 && millis()-lastClickTime<1000){
    firstRun=true; activeMode=-1; buttonClickCount=0; drawMainMenu();
  }
}

/***************** Druck-Anzeige *****************/
void drawPressureDisplayUI(){
  tft.fillScreen(ORANGE_BG); drawHeader();
  tft.setTextColor(COLOR_TEXT,ORANGE_BG); tft.setTextSize(2);
  tft.drawString("DRUCK-ANZEIGE", SIDE_PAD, HDR_H+8);
  tft.drawFastHLine(SIDE_PAD,HDR_H+28,tft.width()-2*SIDE_PAD,ORANGE_ACCENT);
  drawFooter("\x1A  Langer Druck: Zurück");
}

void runPressureDisplay(){
  static unsigned long lastUpdate=0;
  if (millis()-lastUpdate>400){
    int gx=SIDE_PAD, gy=HDR_H+40, gw=tft.width()-2*SIDE_PAD, gh=110;
    tft.fillRect(gx,gy,gw,gh,ORANGE_DARK);
    tft.drawRect(gx,gy,gw,gh,COLOR_TEXT);

    tft.drawFastHLine(gx+10, gy+gh/2, gw-20, COLOR_TEXT);
    for (int i=0;i<=5;i++){
      int x=gx+10 + i*((gw-20)/5);
      tft.drawFastVLine(x, gy+gh/2, 10, COLOR_TEXT);
      tft.setTextDatum(MC_DATUM); tft.setTextSize(1); tft.setTextColor(COLOR_TEXT,ORANGE_DARK);
      char buf[8]; snprintf(buf,sizeof(buf),"%d", 400+i*20); tft.drawString(buf, x, gy+gh/2+16);
    }

    float p=currentPressure;
    if (p<TARGET_MIN) p=TARGET_MIN; if (p>TARGET_MAX) p=TARGET_MAX;
    int xTri = map((int)(p*10), (int)(TARGET_MIN*10), (int)(TARGET_MAX*10), gx+10, gx+gw-10);
    uint16_t col = (currentPressure>=TARGET_MIN && currentPressure<=TARGET_MAX)?COLOR_OK:COLOR_BAD;
    tft.fillTriangle(xTri,gy+gh/2-18, xTri-6,gy+gh/2-6, xTri+6,gy+gh/2-6, col);

    int nx=gx+(gw-136)/2, ny=gy+gh+8, nw=136, nh=26;
    tft.fillRoundRect(nx,ny,nw,nh,13,ORANGE_BG);
    tft.drawRoundRect(nx,ny,nw,nh,13,COLOR_TEXT);
    tft.setTextDatum(MC_DATUM); tft.setTextColor(COLOR_TEXT,ORANGE_BG); tft.setTextSize(2);
    char nb[20]; snprintf(nb,sizeof(nb),"%.1f kPa", currentPressure);
    tft.drawString(nb, nx+nw/2, ny+nh/2);

    int sy=ny+nh+6;
    tft.fillRect(gx,sy,gw,18,ORANGE_BG);
    tft.setTextSize(1); tft.setTextColor(col,ORANGE_BG); tft.setTextDatum(MC_DATUM);
    tft.drawString(
      (currentPressure<TARGET_MIN)?"Druck zu niedrig":
      (currentPressure>TARGET_MAX)?"Druck zu hoch":"Druck OK",
      gx+gw/2, sy+9
    );

    lastUpdate=millis();
    drawHeader();
  }

  if (digitalRead(PIN_JOY_SW)==LOW && millis()-lastButtonPress>800){
    activeMode=-1; drawMainMenu();
  }
}

/***************** Hilfsfunktionen *****************/
float readPressureSensor(){
  Wire.requestFrom(PX2_ADDR, 4);
  if (Wire.available()>=4){
    uint8_t b0=Wire.read(), b1=Wire.read(); Wire.read(); Wire.read();
    uint16_t raw=((uint16_t)(b0&0x3F)<<8)|b1;
    const float OUT_MIN=1638.0f, OUT_MAX=14745.0f;
    float pct=(raw-OUT_MIN)/(OUT_MAX-OUT_MIN);
    if (pct<0)pct=0; if(pct>1)pct=1;
    return P_MIN + pct*(P_MAX-P_MIN);
  }
  return -1.0f;
}

void drawProgressBar(int cx,int y,int w,int h,float pct,uint16_t col,uint16_t bg){
  if (pct<0)pct=0; if(pct>1)pct=1;
  int x=cx-w/2; tft.fillRect(x,y,w,h,bg);
  tft.fillRect(x,y,(int)(w*pct),h,col); tft.drawRect(x,y,w,h,COLOR_TEXT);
}

void activateRelay(uint16_t ms){
  // EIN
  digitalWrite(PIN_RELAY, relayCfg.activeLow? LOW:HIGH);
  relayActive=true; relayTimer=millis()+ms;
}

void checkRelayTimer(){
  if (relayActive && millis()>=relayTimer){
    // AUS
    digitalWrite(PIN_RELAY, relayCfg.activeLow? HIGH:LOW);
    relayActive=false;
  }
}

/***************** Joystick-Achsen & Richtungen *****************/
// Liest die konfigurierte Achse; gibt false, wenn nicht vorhanden
bool readAxis(AxisID id,int &val){
  if (id==AXIS_NONE) return false;
  AxisCfg &ac = axisCfg[(int)id];
  if (!ac.enabled || ac.pin<0) return false;
  int v = analogRead(ac.pin);
  if (ac.invert) v = ADC_MAX - v;
  val = v;
  return true;
}

// Prüft, ob Achse in gewünschte Richtung über Threshold geht
bool axisGoes(AxisID id, Dir2D dir){
  int v; if (!readAxis(id,v)) return false;
  int d = v - ADC_CENTER;
  switch(dir){
    case DIR_UP:    return ( -d > joyCfg.navThreshold ); // kleiner als Center
    case DIR_DOWN:  return (  d > joyCfg.navThreshold );
    case DIR_LEFT:  return ( -d > joyCfg.navThreshold ); // bei X/Z analog
    case DIR_RIGHT: return (  d > joyCfg.navThreshold );
  }
  return false;
}

/***************** Touch – Hauptmenü *****************/
void handleTouchMainMenu(){
  uint16_t tx,ty; if (!getTouch(tx,ty)) return;
  int W=tft.width(), H=tft.height();
  int itemH=44, gap=10;
  int totalH=(itemH*menuCount)+(gap*(menuCount-1));
  int startY=HDR_H + ((H-HDR_H-FTR_H)-totalH)/2;

  if (ty>=startY && ty<=startY+totalH){
    int rel=ty-startY; int slot=rel/(itemH+gap); int inside=rel%(itemH+gap);
    if (slot>=0 && slot<(int)menuCount && inside<itemH){
      currentSelection=slot; drawMenuList();
      activeMode=currentSelection; showModeStartScreen(menuItems[currentSelection]);
    }
  }
}

bool getTouch(uint16_t &x,uint16_t &y){
#ifndef USE_CAP_TOUCH
  if (tft.getTouch(&x,&y)) return true;
  return false;
#else
  if (!ctp.touched()) return false;
  TS_Point p=ctp.getPoint();
  // Mapping an Rotation anpassen (ggf. tauschen/spiegeln)
  x = p.y; y = 320 - p.x;  // typisches Mapping; bei Bedarf ändern
  return true;
#endif
}
